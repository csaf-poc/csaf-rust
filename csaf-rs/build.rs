use std::path::Path;
use std::{fs, io};
use std::string::ToString;
use thiserror::Error;
use typify::{TypeSpace, TypeSpaceSettings};

#[derive(Error, Debug)]
pub enum BuildError {
    #[error("I/O error")]
    IoError(#[from] io::Error),
    #[error("JSON schema error")]
    SchemaError(#[from] typify::Error),
    #[error("Rust syntax error")]
    SyntaxError(#[from] syn::Error),
    #[error("JSON parsing error")]
    JsonError(#[from] serde_json::Error),
    #[error("other error")]
    Other,
}

fn main() -> Result<(), BuildError> {
    // We only need to generate these files as part of our cargo build process,
    // not if we are publishing or getting built by cargo from a crates.io
    // package. This is because the files are generated from the JSON schema
    // files, which are not included in the published package.
    let manifest_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
    if manifest_dir.to_string_lossy().contains("target/package") {
        // If we're in target/package/<version>, we don't need to generate the files
        // because they are already generated in the package.
        return Ok(());
    } else if manifest_dir.to_string_lossy().contains("crates.io") {
        // If we're in a crates.io folder we don't need to generate the files
        // because they are already generated in the debug build.
        return Ok(());
    }

    println!("cargo:rerun-if-changed=build.rs");

    // All schema files for change watching
    let schema_configs = [
        ("./src/csaf/csaf2_0/csaf_json_schema.json", "csaf/csaf2_0/schema.rs", true),
        ("./src/csaf/csaf2_1/ssvc-1-0-1-merged.schema.json", "csaf/csaf2_1/ssvc_schema.rs", false),
        ("./src/csaf/csaf2_1/csaf.json", "csaf/csaf2_1/schema.rs", true),
        ("../ssvc/data/schema/v1/Decision_Point-1-0-1.schema.json", 
         "csaf/csaf2_1/ssvc_dp_schema.rs", false)
    ];

    // Register watching for all inputs
    for (input, _, _) in &schema_configs {
        println!("cargo:rerun-if-changed={}", input);
    }

    // Execute all listed schema builds
    for (input, output, no_date_time) in &schema_configs {
        build(input, output, *no_date_time)?;
    }

    generate_language_subtags()?;

    Ok(())
}

fn build(input: &str, output: &str, no_date_time: bool) -> Result<(), BuildError> {
    let content = fs::read_to_string(&input)?;
    let mut schema_value = serde_json::from_str(&content)?;
    if no_date_time {
        // Recursively search for "format": "date-time" and remove this format
        remove_datetime_formats(&mut schema_value);
    }
    let schema: schemars::schema::RootSchema = serde_json::from_value(schema_value)?;

    let mut type_space = TypeSpace::new(
        TypeSpaceSettings::default()
            .with_struct_builder(true)
            .with_derive("PartialEq".into())
            .with_derive("Eq".into()),
    );
    type_space.add_root_schema(schema)?;

    let content = prettyplease::unparse(&syn::parse2::<syn::File>(type_space.to_stream())?);

    let mut out_file = Path::new("src").to_path_buf();
    out_file.push(output);
    Ok(fs::write(out_file, content)?)
}

fn remove_datetime_formats(value: &mut serde_json::Value) {
    if let serde_json::Value::Object(map) = value {
        if let Some(format) = map.get("format") {
            if format.as_str() == Some("date-time") {
                // Remove the format property entirely
                map.remove("format");
            }
        }

        // Recursively process all values in the object
        for (_, v) in map.iter_mut() {
            remove_datetime_formats(v);
        }
    } else if let serde_json::Value::Array(arr) = value {
        for item in arr.iter_mut() {
            remove_datetime_formats(item);
        }
    }
}

/// Compile-time-embedded language-subtag-registry.txt
const LANGUAGE_REGISTRY: &str = include_str!("../assets/language-subtag-registry.txt");

fn generate_language_subtags() -> Result<(), BuildError> {
    let mut subtags = Vec::new();
    let mut current_entry_type = None;

    for line in LANGUAGE_REGISTRY.lines() {
        let line = line.trim();

        if line.is_empty() || line.starts_with("%%") {
            current_entry_type = None;
            continue;
        }

        if let Some(type_value) = line.strip_prefix("Type: ") {
            current_entry_type = Some(type_value.to_string());
            continue;
        }

        if let Some(ref entry_type) = current_entry_type {
            if entry_type == "language" {
                if let Some(subtag) = line.strip_prefix("Subtag: ") {
                    subtags.push(subtag.to_string());
                }
            }
        }
    }

    subtags.sort_unstable();

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs\n");
    code.push_str("pub static LANGUAGE_SUBTAGS_ARRAY: &[&str] = &[\n");

    for subtag in &subtags {
        code.push_str(&format!("    \"{}\",\n", subtag));
    }

    code.push_str("];\n\n");

    // ZusÃ¤tzlich eine Lookup-Funktion generieren
    code.push_str("pub fn is_valid_language_subtag(subtag: &str) -> bool {\n");
    code.push_str("    LANGUAGE_SUBTAGS_ARRAY.binary_search(&subtag).is_ok()\n");
    code.push_str("}\n");

    let out_path = Path::new("src")
        .join("csaf")
        .join("generated")
        .join("language_subtags.rs");
    fs::write(&out_path, code)?;

    println!("cargo:rerun-if-changed=../assets/language-subtag-registry.txt");
    Ok(())
}
